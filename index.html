<!DOCTYPE html>
<html>
<head>
	<title>Bus Transit</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<link rel="stylesheet" href="css/leaflet.css"/>
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="example.min.js"></script>
	<script src="lib/rbush.js"></script>
	<script src="lib/turf.min.js"></script>
	<script src="lib/jquery-3.3.1.js"></script>
	<link rel="stylesheet" href="style.css">

</head>
<body>
<main>
	<figure>
		<div id="map"></div>
	</figure>
	<div class="table"></div>
	<div class="pixi"></div>
</main>
<script>

	d3.csv('coords.csv')
				  .then(function(names) {
				      d3.csv('names_coords.csv')
				        .then(function(coords) {

							// created geojson out of basic data
							var geojson = coords.map(function (d) {
								return {
									type: "Feature",
									properties: d,
									geometry: {
										type: "Point",
										coordinates: [+d.Long, +d.Lat]
									}
								}
							});

							var nested_names = d3.nest()
									.key(function(d) { return d.first.trim(); })
									.entries(names);

				            var nested_data = d3.nest()
				                            .key(function(d) {
				                                return d.place_short.trim();
				                            })
				                            .map(coords);


							nested_names.forEach(function(d, i) {
								d.values.forEach(function (dd,ii) {
									if (nested_data['$' + dd.first.trim()] != undefined && nested_data['$' + dd.second.trim()] != undefined)
									{
										nested_names[i].values[ii].coords = [[+nested_data['$' + dd.first.trim()][0].Lat, +nested_data['$' + dd.first.trim()][0].Long], [+nested_data['$' + dd.second.trim()][0].Lat, +nested_data['$' + dd.second.trim()][0].Long]]
									}
									else {
										nested_names[i].values[ii].coords = 'NO'
									}
								})
							});

							nested_names = d3.nest().key(function(d) {return d.key;}).map(nested_names);


				            
				            var result = names.map(function(name) {
				                if (nested_data['$' + name.first.trim()] != undefined && nested_data['$' + name.second.trim()] != undefined)
				                {
				                    return {
				                        'departure':name.first,
										'arrival': name.second,
										'route_operator': name.route_operator,
				                        'coords': [[+nested_data['$' + name.first.trim()][0].Lat, +nested_data['$' + name.first.trim()][0].Long], [+nested_data['$' + name.second.trim()][0].Lat, +nested_data['$' + name.second.trim()][0].Long]]
				                    }
				                }
				                else {
				                    return 'no'
				                }

				            });

				            var lineCoord = result.filter(function(d) {
				            	return d != 'no'
				            });
							
							var nested_cities = d3.nest().key(function(d) {return d.departure;}).map(result);
							var nested_operators = d3.nest().key(function(d) {return d.route_operator;}).map(result);

							var operator_names = d3.map(function(d) {return d.route_operator;}).entries(result);
							var city_names = d3.nest().key(function(d) {return d.departure;}).entries(result)
									.filter(d => d.key != 'undefined');


							var cities = d3.select('div.table').selectAll('div')
									.data(city_names)
									.enter()
									.append("div")
									.attr('class', 'city');

							var cityNames = cities.append('div')
									.text(d => d.key)
									.attr('class', 'cityTitle');

							//.append('div').attr('class', 'routesList')
							var routes =  cities.selectAll('div')
									.data(d => d.values)
									.enter()
									.append('div')
									.attr('class', 'route')
									.style('display', 'none');

							routes.append('div')
									.attr('class', 'routeInfo')
									.html(function (d) {
										return `
										<p class="routeTitle">${d.departure} - ${d.arrival}</p>
										<p class="routeProperty">${ 'Назва перевізника: ' + d.route_operator.split (',', 1) || ''}</p>
									    `
									});


							var map = L.map('map').setView([50.440700, 30.521518], 8);

							$('#map').css('position', 'sticky')

			var CartoDB_PositronOnlyLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
				attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
				subdomains: 'abcd',
				maxZoom: 19
			}).addTo(map);


			var geojsonMarkerOptions = {
				radius: 4,
				fillColor: "#808080",
				color: "#000",
				weight: 0,
				opacity: 1,
				fillOpacity: 0.8,
				bubblingMouseEvents: false
			};
							var tree = rbush();




							//created leaflet markers
			var markers = L.geoJSON(geojson,{
				pointToLayer: function (feature, latlng) {

					try {
						return L.circleMarker(latlng, geojsonMarkerOptions)
					}
					catch(err) {
						debugger;
					}

				}
			}).addTo(map);

			var backgroundOverlay = (function() {
				var frame = null;
				var firstDraw = true;
				var prevZoom;


				var projectedPolygon;


				var polygonLatLngs = [
					[51.509, -0.08],
					[51.503, -0.06],
					[51.51, -0.047],
					[51.509, -0.08]
				];

				var circleCenter = [51.508, -0.11];
				var projectedCenter;
				var circleRadius = 85;

				var triangle = new PIXI.Graphics();
				triangle.popup = L.popup()
						.setLatLng([51.5095, -0.063])
						.setContent('I am a polygon.');
				var circle = new PIXI.Graphics();
				circle.popup = L.popup()
						.setLatLng(circleCenter)
						.setContent('I am a circle.');



				var pixiContainer = new PIXI.Graphics();
				pixiContainer.interactive = true;
				pixiContainer.buttonMode = true;

				var doubleBuffering = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

				return L.pixiOverlay(function(utils) {
					if (frame) {
						cancelAnimationFrame(frame);
						frame = null;
					}
					var zoom = utils.getMap().getZoom();
					var container = utils.getContainer();
					var anotherContainer = utils.getContainer();
					var renderer = utils.getRenderer();
					var project = utils.latLngToLayerPoint;
					var scale = utils.getScale();

					if (firstDraw) {
						var getRenderer = utils.getRenderer;
						utils.getMap().on('click', function(e) {
							// not really nice but much better than before
							// good starting point for improvements
							var interaction = utils.getRenderer().plugins.interaction;
							var pointerEvent = e.originalEvent;
							var pixiPoint = new PIXI.Point();
							// get global click position in pixiPoint:
							interaction.mapPositionToPoint(pixiPoint, pointerEvent.clientX, pointerEvent.clientY);
							// get what is below the click if any:
							var target = interaction.hitTest(pixiPoint, container);
							if (target && target.popup) {
								target.popup.openOn(map);
							}
						});

						projectedPolygon = polygonLatLngs.map(function(coords) {return project(coords);});

						projectedCenter = project(circleCenter);
						circleRadius = circleRadius / scale;
					}
					if (firstDraw || prevZoom !== zoom) {

						container.clear();

						var stringToColour = function(str) {
							var hash = 0;
							for (var i = 0; i < str.length; i++) {
								hash = str.charCodeAt(i) + ((hash << 5) - hash);
							}
							var colour = '#';
							for (var i = 0; i < 3; i++) {
								var value = (hash >> (i * 8)) & 0xFF;
								colour += ('00' + value.toString(16)).substr(-2);
							}
							return colour;
						};


						lineCoord.forEach(function(d) {

							var bounds;

							// if false it would disappear
							container.visible = true;


							var color = '#7e6f6f';
							container.beginFill(0xFF3300);
							container.lineStyle((0.5/scale), color.replace('#', '0x'), 1);


							// draw a shape
							container.moveTo(project(d.coords[0]).x, project(d.coords[0]).y);
							container.lineTo(project(d.coords[1]).x, project(d.coords[1]).y);
							container.endFill();

							bounds = L.bounds(L.bounds(d.coords));

							tree.insert({
								minX: bounds.min.x,
								minY: bounds.min.y,
								maxX: bounds.max.x,
								maxY: bounds.max.y,
								feature: d
							});


						});


					}

					firstDraw = false;
					prevZoom = zoom;
					renderer.render(container);


				}, pixiContainer, {
					doubleBuffering: doubleBuffering,
					autoPreventDefault: false
				});
			})();

			var selectedOverlay = (function() {
				var frame = null;
				var firstDraw = true;
				var prevZoom;


				var pixiContainer = new PIXI.Graphics();
				pixiContainer.interactive = true;
				pixiContainer.buttonMode = true;
				var selectedCity;
				var selectedMarchRoute;
				var selectedOperator;
//				var selectedStatus = false;



				var doubleBuffering = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

				return L.pixiOverlay(function(utils) {
					if (frame) {
						cancelAnimationFrame(frame);
						frame = null;
					}
					var zoom = utils.getMap().getZoom();
					var container = utils.getContainer();
					var renderer = utils.getRenderer();
					var project = utils.latLngToLayerPoint;
					var scale = utils.getScale();

					if (firstDraw) {
						var getRenderer = utils.getRenderer;
						utils.getMap().on('click', function(e) {
							// not really nice but much better than before
							// good starting point for improvements
							var interaction = utils.getRenderer().plugins.interaction;
							var pointerEvent = e.originalEvent;
							var pixiPoint = new PIXI.Point();
							// get global click position in pixiPoint:
							interaction.mapPositionToPoint(pixiPoint, pointerEvent.clientX, pointerEvent.clientY);
							// get what is below the click if any:
							var target = interaction.hitTest(pixiPoint, container);
							if (target && target.popup) {
								target.popup.openOn(map);
							}
						});
					}
					if (firstDraw || prevZoom !== zoom) {

						container.clear();

//						var stringToColour = function(str) {
//							var hash = 0;
//							for (var i = 0; i < str.length; i++) {
//								hash = str.charCodeAt(i) + ((hash << 5) - hash);
//							}
//							var colour = '#';
//							for (var i = 0; i < 3; i++) {
//								var value = (hash >> (i * 8)) & 0xFF;
//								colour += ('00' + value.toString(16)).substr(-2);
//							}
//							return colour;
//						};

						drawSelectedCity(selectedCity);


						function drawSelectedCity(selectedCity) {
							if (selectedCity) {
								nested_names[selectedCity][0].values.forEach(function(d) {

									if (d.coords != 'NO') {
										container.visible = true;

										var color = '#ea3e13';
										container.beginFill(0xFF3300);
										container.lineStyle((3/scale), color.replace('#', '0x'), 1);


										// draw a shape
										container.moveTo(project(d.coords[0]).x, project(d.coords[0]).y);
										container.lineTo(project(d.coords[1]).x, project(d.coords[1]).y);
										container.endFill();

									}
//								renderer.render(container);

								})
							}
						}

						if (selectedMarchRoute) {
							createLine(selectedMarchRoute);
						}

						if (selectedOperator) {
							nested_operators['$' + selectedOperator].map(d => {
								var color = '#ea3e13';
							container.lineStyle((3/scale), color.replace('#', '0x'), 1);

							// draw a shape
							container.moveTo(project(d.coords[0]).x, project(d.coords[0]).y);
							container.lineTo(project(d.coords[1]).x, project(d.coords[1]).y);
							container.endFill();
						})

						}

						cityNames.on('click', function () {

							container.clear();

							var $t = $(this);

							selectedCity = "$"+$t.text();

							if ( $t.hasClass('open') ) {
								$t.siblings('.route')
										.slideUp();
								$t.removeClass('open');
							} else {
								$('.route').slideUp('slow', function () {
									setTimeout(2000);

									var topOff = $t.offset().top;
									$(window).scrollTop(topOff);
								});
								$('.open').removeClass('open');
								$t.siblings('.route')
										.slideDown('slow', function () {
											$(this).css('display', 'block');
										});
								$t.addClass('open');
							}

							drawSelectedCity(selectedCity)
							renderer.render(container);
						});

						
						markers.on('click', function (d) {

								container.clear();

								selectedCity = '$' + d.sourceTarget.feature.properties[0];

								nested_names[selectedCity][0].values.forEach(function (d) {

									if (d.coords != 'NO') {
										container.visible = true;

										var color = '#ea3e13';
										container.lineStyle((3/scale), color.replace('#', '0x'), 1);


										// draw a shape
										container.moveTo(project(d.coords[0]).x, project(d.coords[0]).y);
										container.lineTo(project(d.coords[1]).x, project(d.coords[1]).y);
										container.endFill();
									}
								});

							renderer.render(container);
							selectedMarchRoute = undefined;

						});

						map.on('click', function (d) {

								var possibleRoutes = findRoute(d.latlng);
								var result = measureDistance(d.latlng, possibleRoutes);
								createLine(result[0]);

								selectedMarchRoute = result[0];


						});

						map.on('mousemove', function (d) {
							var possibleRoutes = findRoute(d.latlng);
							var result = measureDistance(d.latlng, possibleRoutes);

							if (result[1] === true) {
								document.getElementById('map').style.cursor = 'pointer';
							}
							else {
								document.getElementById('map').style.cursor = '';
							}

						});


						function findRoute(latlng) {
							// alert(point.x+ " " +point.y);
							var features = tree.search({
								minX: latlng.lat,
								minY: latlng.lng,
								maxX: latlng.lat,
								maxY: latlng.lng
							});

							return features

						}

						function measureDistance(point, possibleRoutes) {
							var current, state;


							possibleRoutes.forEach(function (d) {
								var pt = turf.point([point.lat, point.lng]);
								var line = turf.lineString([d.feature.coords[0],d.feature.coords[1]]);

								var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});

								var distProportion = 5/Math.pow(2, zoom-8);

								if (distance > distProportion) return;

								if (!current || distance < current.dist)
								{
									current = {'dist': distance, 'feature': d.feature};
									state = true;
								}

							});

							return [current, state] ;

						}

						function createLine(current) {

							container.clear();

							var color = '#ea3e13';
							//var widthProportion = 0.5/Math.pow(2, zoom-8);

							container.lineStyle(3/scale, color.replace('#', '0x'), 1);


							// draw a shape
							container.moveTo(project(current.feature.coords[0]).x, project(current.feature.coords[0]).y);
							container.lineTo(project(current.feature.coords[1]).x, project(current.feature.coords[1]).y);
							container.endFill();

							renderer.render(container);
							return
						}
					}

					firstDraw = false;
					prevZoom = zoom;
					renderer.render(container);


				}, pixiContainer, {
					doubleBuffering: doubleBuffering,
					autoPreventDefault: false
				});
			})();

							backgroundOverlay.addTo(map);
			selectedOverlay.addTo(map);
							map.removeLayer(CartoDB_PositronOnlyLabels);



						})
				  });

</script>
</body>
</html>
